import ds/array;
import ds/tree;
import nemo_parser;
import nemo_vnemo;

export{
    // conjunction of ac and all vc
    n2c(p: Prog) -> Formula;
    c2s(f: Formula) -> string;
}

n2c(p: Prog) -> Formula {
    // body & aftercondition
    ac = b2ac(p.b, p.ac.f);
    vc = b2vc(p.b, p.ac.f);
    //lazy way of aestetic fold artifacts removal
    denop(denop(denop(denop(
        And(p.bc.f, And(p.ac.f, And(ac, vc)))
    ))));
}

b2ac(body: Body, f: Formula) -> Formula{
    // after-condition appears a bit more than should
    // but it does not affect conjunction
    switch (body) {
        nAssign(v, e): Repl(f, v, e);
        nTest(e): Impl(e, f);
        nSeq(b): foldr(b, f, \acc, elem -> b2ac(elem, acc));
        nUnion(b): fold(b, Nop(), \acc, elem -> And(acc, b2ac(elem, f)));
        nIter(a, b): a.f;
        nPrint(e): f;
    }
}

b2vc(body: Body, f: Formula) -> Formula{
    switch (body) {
        nAssign(v, e): Nop();
        nTest(e): Nop();
        nSeq(b): {
            fold(
            mapi(b, \ind, elem -> if(ind == length(b) - 1){ b2vc(elem,f) } else { b2vc(elem, b2ac(b[ind + 1], f)) }),
            Nop(),
            \acc, elem -> And(acc, elem))
        }
        // implementation with [] instead of pair made this o(n2) abomination
        // stupid me, should've stuck with pairs
        nUnion(b): {
            fold(
            mapi(b, \ind, elem -> if(ind == length(b) - 1){ b2vc(elem, f) } else { b2vc(elem, b2ac(nSeq(tailFrom(b, ind + 1))  ,f))}),
            Nop(),
            \acc, elem -> And(acc, elem))
        }
        nIter(a, b): And(b2vc(b, f), And(Impl(a.f, f), Impl(a.f, b2ac(b, a.f))));
        nPrint(e): Nop();
    }
}

c2s(f: Formula) -> string {
    switch (f) {
        Forall(x, e) : strGlue(["(forall", c2s(x), c2s(e), ")"], " ");
        Exists(x, e) : strGlue(["(exists", c2s(x), c2s(e), ")"], " ");
        Or(l, r):      strGlue(["( or", c2s(l), c2s(r), ")"],      " ");
        And(l, r):     strGlue(["( and", c2s(l), c2s(r), ")"],     " ")
        Impl(l, r):    strGlue(["( =>", c2s(l), c2s(r), ")"],      " ");
        Neg(e):        strGlue(["( not", c2s(e), ")"],             " ");
        Repl(e, x, t): strReplace(c2s(e), c2s(x), c2s(t));
        Int(v):        i2s(v);
        Arr(a):        "[err]"// TODO array expression
        Var(n):        n;
        Sum(l, r):     strGlue(["( +", c2s(l), c2s(r), ")"],      " ");
        Sub(l, r):     strGlue(["( -", c2s(l), c2s(r), ")"],      " ");
        Prod(l, r):    strGlue(["( *", c2s(l), c2s(r), ")"],      " ");
        Div(l, r):     strGlue(["( /", c2s(l), c2s(r), ")"],      " ");
        aSet(a, i, v): strGlue(["(store", c2s(a), c2s(i), c2s(v), ")"], " ");
        aGet(a, i):    strGlue(["(select", c2s(a), c2s(i), ")"],  " ");
        aLen(a):       "err"; //should not be in formula
        Not(e):        strGlue(["( not", c2s(e), ")"],             " ");
        Less(l, r):    strGlue(["( <", c2s(l), c2s(r), ")"],      " ");
        Nop():         "(= 1 1)"
    }
}

denop(f: Formula) -> Formula{
    switch (f) {
        And(l, r):     anddenop(l,r);
        Impl(l, r): if(l == Nop()){r} else { if(r == Nop()){ Nop() }else{ f }};
        default: f;
    }
}

anddenop(l:Formula, r:Formula) -> Formula{
    if(l == Nop()){
        if(r == Nop()){
            Nop()
        }else{
            denop(r)
        }
    } else {
        if(r == Nop()){
            denop(l)
        } else {
            And(denop(l), denop(r))
        }
    }
}
