import ds/array;
import ds/tree;
import nemo_parser;
import nemo_vnemo;

export{
    Conditions : (p: Prog, ac : Formula, vc: [Formula]);
    n2c(p: Prog) -> Conditions;
}

// ac without \phi => ac
b2ac(body: Body, f: Formula) -> Formula;
b2vc(body: Body, f: Formula) -> [Formula];
//recursive simplification of and(nop, nop)
rdenop(f: Formula, amount: int) -> Formula;
denop(f: Formula) -> Formula;
anddenop(l:Formula, r:Formula) -> Formula;

n2c(p: Prog) -> Conditions{
    ac = rdenop(
        Impl(p.bc.f, b2ac(p.b, p.ac.f)),
        2
    );
    vc = rdenop(
        b2vc(p.b, p.ac.f),
        2
    );
    Conditions(p, ac, vc);
}

b2ac(body: Body, f: Formula) -> Formula{
    // after-condition appears a bit more than should
    // but it does not affect conjunction
    switch (body) {
        nAssign(v, e): Repl(f, v, e);
        nTest(e): Impl(e, f);
        nSeq(b): foldr(b, f, \acc, elem -> b2ac(elem, acc));
        nUnion(b): fold(b, Nop(), \acc, elem -> And(acc, b2ac(elem, f)));
        nIter(a, b): a.f;
        nPrint(e): f;
    }
}

b2vc(body: Body, f: Formula) -> [Formula]{
    switch (body) {
        nAssign(v, e): Nop();
        nTest(e): Nop();
        nSeq(b): {
            fold(
            mapi(b, \ind, elem -> if(ind == length(b) - 1){ b2vc(elem,f) } else { b2vc(elem, b2ac(b[ind + 1], f)) }),
            Nop(),
            \acc, elem -> And(acc, elem))
        }
        // implementation with [] instead of pair made this o(n2) abomination
        // stupid me, should've stuck with pairs
        nUnion(b): {
            fold(
            mapi(b, \ind, elem -> if(ind == length(b) - 1){ b2vc(elem, f) } else { b2vc(elem, b2ac(nSeq(tailFrom(b, ind + 1)) , f))}),
            Nop(),
            \acc, elem -> And(acc, elem))
        }
        nIter(a, b): And(b2vc(b, f), And(Impl(a.f, f), Impl(a.f, b2ac(b, a.f))));
        nPrint(e): Nop();
    }
}

rdenop(f: Formula, amount: int) -> Formula{
    if(denopamount > 0){
        rdenop(denop(f), denopamount - 1);
    } else {
        denop(f);
    }
}

denop(f: Formula) -> Formula{
    switch (f) {
        And(l, r):     anddenop(l,r);
        Impl(l, r): if(l == Nop()){r} else { if(r == Nop()){ Nop() }else{ f }};
        default: f;
    }
}

anddenop(l:Formula, r:Formula) -> Formula{
    if(l == Nop()){
        if(r == Nop()){
            Nop()
        }else{
            denop(r)
        }
    } else {
        if(r == Nop()){
            denop(l)
        } else {
            And(denop(l), denop(r))
        }
    }
}
