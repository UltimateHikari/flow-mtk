import ds/array;
import ds/tree;
import nemo_parser;
import nemo_vnemo;

export{
    Conditions : (p: Prog, ac : Formula, vc: [Formula]);
    n2c(p: Prog) -> Conditions;
}

// ac without \phi => ac
b2ac(body: Body, f: Formula) -> Formula;
b2vc(body: Body, f: Formula) -> [Formula]; //TODO make it [Formula]
//recursive simplification of and(nop, nop)
rdenop(f: Formula, amount: int) -> Formula;
denop(f: Formula) -> Formula;
anddenop(l:Formula, r:Formula) -> Formula;

n2c(p: Prog) -> Conditions{
    ac = rdenop(
        Impl(p.bc.f, b2ac(p.b, p.ac.f)),
        2
    );
    vc = map(
        b2vc(p.b, p.ac.f),
        \x ->rdenop(x, 2)
        );
    Conditions(p, ac, vc);
}

b2ac(body: Body, f: Formula) -> Formula{
    // after-condition appears a bit more than should
    // but it does not affect conjunction
    switch (body) {
        nAssign(v, e): Repl(f, v, e);
        nTest(e): Impl(e, f);
        nSeq(b): {
            if(length(b) == 2){
                b2ac(b[0], b2ac(b[1], f));
            } else {
                b2ac(b[0], b2ac(nSeq(tailFrom(b,1)), f));
            }
        }
        nUnion(b): fold(b, Nop(), \acc, elem -> And(acc, b2ac(elem, f)));
        nIter(a, b): a.f;
        nPrint(e): f;
    }
}

b2vc(body: Body, f: Formula) -> [Formula]{
    switch (body) {
        nAssign(v, e): [];
        nTest(e): [];
        nSeq(b): {
            if(length(b) == 2){
                concat(b2vc(b[0],b2ac(b[1],f)), b2vc(b[1],f));
            } else {
                tail = nSeq(tailFrom(b,1));
                concat(b2vc(b[0],b2ac(tail,f)), b2vc(tail,f));
            }
        }
        // implementation with [] instead of pair made this o(n2) abomination
        // stupid me, should've stuck with pairs
        nUnion(b): {
            fold(
            map(b, \elem -> b2vc(elem, f)),
            [],
            \acc, elem -> concat(acc, elem))
        }
        nIter(a, b): {
            concat(b2vc(b, f), [Impl(a.f, f), Impl(a.f, b2ac(b, a.f))]);
        }
        nPrint(e): [];
    }
}

rdenop(f: Formula, amount: int) -> Formula{
    if(amount > 0){
        rdenop(denop(f), amount - 1);
    } else {
        denop(f);
    }
}

denop(f: Formula) -> Formula{
    switch (f) {
        And(l, r):     anddenop(l,r);
        Impl(l, r): if(l == Nop()){r} else { if(r == Nop()){ Nop() }else{ f }};
        default: f;
    }
}

anddenop(l:Formula, r:Formula) -> Formula{
    if(l == Nop()){
        if(r == Nop()){
            Nop()
        }else{
            denop(r)
        }
    } else {
        if(r == Nop()){
            denop(l)
        } else {
            And(denop(l), denop(r))
        }
    }
}
