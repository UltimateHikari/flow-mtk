import maybe;
import string;
import lingo/pegcode/driver;
import ds/tree;
import ds/array;
import dynamic;

export{
    Prog: (h: [Decl], b: Body, bc: Annotation, ac: Annotation);
    Decl: (v: Var, t: Type);

    Val ::= Int, Arr;
        Int: (v: int);
        Arr: (a: [Val]);
    
    Var(n: string);
    Type ::= bType, arrType;
        bType : (t: string);
        arrType : (t: Type);

    Body ::= nAssign, nTest, nSeq, nUnion, nIter, nPrint;
        nAssign: (v: Var, e: Exp);
        nTest:  (e: Exp);
        nSeq: (b: [Body]);
        nUnion: (b: [Body]);
        nIter: (a: Annotation, b: Body);
        nPrint: (e: Exp);

    Exp ::= ArExp, NemoExp, CompExp;
        ArExp ::= Val, Var, Sum, Sub, Prod, Div;
            Sum : (l: Exp, r: Exp);
            Prod : (l: Exp, r: Exp);
            Sub : (l: Exp, r: Exp);
            Div : (l: Exp, r: Exp);
        NemoExp ::= aSet, aGet, aLen;
            aSet : (a: Var, i: Int, v: Exp); 
            aGet : (a: Var, i: Int);
            aLen : (a: Var);
        CompExp ::= Not, Less, More, ELess, EMore, Eq;
            Not(e: Exp);
            Less : (l: Exp, r: Exp);
            More : (l: Exp, r: Exp);
            ELess : (l: Exp, r: Exp);
            EMore : (l: Exp, r: Exp);
            Eq : (l: Exp, r: Exp);

    Annotation : (f: Formula);
    Formula ::= LogicFormula, Exp, Nop;
        LogicFormula ::= Forall, Exists, Or, And, Impl, Neg, Repl;
            Forall : (x: Var, e: Formula);
            Exists : (x: Var, e: Formula);
            Or : (l: Formula, r: Formula);
            And : (l: Formula, r: Formula);
            Impl : (l: Formula, r: Formula);
            Neg : (e:Formula);
            Repl : (e: Formula, x: Var, t: Exp);
        Nop : (); // empty formula for reasons of non-maybe strictness

    parse(s: string) -> Maybe<Prog>;
    // no pr2s for now

    ErrorProg = Prog([], nTest(Int(0)), Annotation(Nop()), Annotation(Nop()));
}

grammar = "#include nemo.lingo";

buildUnion(xs : [flow]) -> nUnion{
    nUnion(arrayPush(xs[0], xs[1]));
}

buildSeq(xs : [flow]) -> nSeq{
    nSeq(arrayPush(xs[0], xs[1]));
}

buildWhile(xs: [flow]) -> nSeq{
    nSeq([nIter(xs[0], nSeq([nTest(xs[1]), xs[2]])), nTest(Not(xs[1])) ]);
}

parse(s: string) -> Maybe<Prog>{
    parser = compilePegGrammar(grammar);
    specialPegActions = {
        t = setTree(defaultPegActions.t, "buildUnion", buildUnion);
        t2 = setTree(t, "buildSeq", buildSeq);
        t3 = setTree(t2, "buildWhile", buildWhile);
        SemanticActions(t3);
    }
    ret = parsic3(parser, s, specialPegActions, ErrorProg);
    if(ret.third == "") { Some(ret.first); } else { println(ret.third); None() }
}
